---
layout: post
title:  "How to never write a for-loop ever again!"
date:   2014-02-19 13:24:43
categories: blog
tags: functional-programming nodejs JS
---

I like to think that Javascript is a very unique programming language. While it is super easy to get started in Javascript (thanks to the [power of its View Source](http://www.codinghorror.com/blog/2006/08/the-power-of-view-source.html)), it takes years of experience to master the language. Indeed, the [wat effect](https://www.destroyallsoftware.com/talks/wat) of JS does make it difficult to develop any expertise in the language. 

One strategy I decided to follow while learning Javascript is to force myself to write in the semantics of the language. JS is a functional language, meaning that computation should be treated as a by-product of the execution of one or multiple functions. This is certainly very different from the imperative perspective, where it is about collecting information and transforming it into decisions. Take this example, that occured to me today.

Consider a sizeable array of events, which are modelled as objects of the form:

```javascript
var event = {
    action : "tap",
    timestamp : 1393019607
};

events = [{
        "action" : "tap",
        "timestamp" : 1393019607
      }, {
        "action" : "swipe",
        "timestamp" : 1393019627
      }
      // a long series of events
      ];
```

Given a certain priority in the events' type, we would like to be able to find the event with highest priority in the list. Nothing too complicated; a simple linear search:

```javascript



        // Identify the most important event index
        _.each(events, function(event, index) {
            var bestRank = _.indexOf(actionOrder, events[best].action);
            var currentRank = _.indexOf(actionOrder, event.action);
            best = (currentRank < bestRank) ? index : best;
        });

    //Identify index of most important event, starts lookup at index `from`
    var indexMostImportant = function(events, from){
	var newEvents = from? events.slice(from): events;

	var best = _.reduce(newEvents, function(best, event, index){
	    var currentRank =  _.indexOf(actionOrder, event.action);
	    best = ( best.actionOrder > _.indexOf(actionOrder, event.action ))?
		{ index: index, actionRank: currentRank }: best;
	}, {
	    index:0,
	    actionRank: _.indexOf(events[0].action)
	});
	return best.index;
    };


